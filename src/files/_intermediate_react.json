{
    "questions": [
      {
        "question": "What is the purpose of `useCallback` hook in React?",
        "options": [
          "To return a memoized version of a callback function",
          "To manage side effects",
          "To update the DOM directly",
          "To render components"
        ],
        "answer": "To return a memoized version of a callback function"
      },
      {
        "question": "What does `useMemo` do in React?",
        "options": [
          "It memoizes a computed value to avoid recalculating",
          "It returns a new component",
          "It re-renders the component on every render",
          "It adds a side effect to the component"
        ],
        "answer": "It memoizes a computed value to avoid recalculating"
      },
      {
        "question": "What is the difference between `useEffect` and `useLayoutEffect`?",
        "options": [
          "`useLayoutEffect` fires synchronously after all DOM mutations, `useEffect` runs asynchronously after painting",
          "`useLayoutEffect` is used for async operations, `useEffect` is for synchronous",
          "`useLayoutEffect` runs before rendering, `useEffect` runs after",
          "`useLayoutEffect` modifies the DOM, `useEffect` handles events"
        ],
        "answer": "`useLayoutEffect` fires synchronously after all DOM mutations, `useEffect` runs asynchronously after painting"
      },
      {
        "question": "What is the `Context API` used for in React?",
        "options": [
          "To pass data deeply through a component tree without props",
          "To manage the lifecycle of components",
          "To handle forms and inputs",
          "To add event listeners"
        ],
        "answer": "To pass data deeply through a component tree without props"
      },
      {
        "question": "What is `React.memo` used for?",
        "options": [
          "To prevent unnecessary re-renders of functional components",
          "To optimize the performance of class components",
          "To handle asynchronous functions",
          "To handle event delegation"
        ],
        "answer": "To prevent unnecessary re-renders of functional components"
      },
      {
        "question": "What does the `useRef` hook do in React?",
        "options": [
          "It returns a mutable ref object that persists across re-renders",
          "It creates a reference to the parent component",
          "It triggers a re-render when a value changes",
          "It creates a copy of the state"
        ],
        "answer": "It returns a mutable ref object that persists across re-renders"
      },
      {
        "question": "How do you handle performance optimization in React with large lists of items?",
        "options": [
          "Using React's `Virtual DOM`",
          "Using `React.memo` and `useCallback`",
          "Using `React.lazy` and `Suspense`",
          "By breaking the list into smaller components"
        ],
        "answer": "Using `React.memo` and `useCallback`"
      },
      {
        "question": "What is code splitting in React?",
        "options": [
          "A technique used to split the code into smaller bundles to improve performance",
          "A method for splitting components into multiple files",
          "A feature of the `useState` hook",
          "A way to load JavaScript in parallel"
        ],
        "answer": "A technique used to split the code into smaller bundles to improve performance"
      },
      {
        "question": "Which of the following is true about `React.lazy`?",
        "options": [
          "It allows you to load components lazily via dynamic imports",
          "It delays the rendering of components based on state",
          "It caches components to avoid re-rendering",
          "It creates a ref to a lazy-loaded component"
        ],
        "answer": "It allows you to load components lazily via dynamic imports"
      },
      {
        "question": "What is a higher-order component (HOC) in React?",
        "options": [
          "A function that takes a component and returns a new component",
          "A special type of class component",
          "A component that handles events",
          "A component that fetches data from an API"
        ],
        "answer": "A function that takes a component and returns a new component"
      },
      {
        "question": "How does React's `Suspense` work?",
        "options": [
          "It waits for lazy-loaded components to load and shows a fallback UI in the meantime",
          "It handles asynchronous operations",
          "It suspends the rendering of components until the next render cycle",
          "It stops a component from re-rendering until data is fetched"
        ],
        "answer": "It waits for lazy-loaded components to load and shows a fallback UI in the meantime"
      },
      {
        "question": "What does `PropTypes` do in React?",
        "options": [
          "It validates the types of props passed to a component",
          "It is used to set default values for props",
          "It handles state management in React",
          "It is used for styling components"
        ],
        "answer": "It validates the types of props passed to a component"
      },
      {
        "question": "How does the `useReducer` hook differ from `useState`?",
        "options": [
          "`useReducer` is suitable for more complex state logic and multiple state transitions",
          "`useReducer` is used for simple state updates",
          "`useState` is asynchronous, while `useReducer` is synchronous",
          "`useState` manages multiple states, while `useReducer` manages a single state"
        ],
        "answer": "`useReducer` is suitable for more complex state logic and multiple state transitions"
      },
      {
        "question": "What is the difference between controlled and uncontrolled components in React?",
        "options": [
          "Controlled components have their state managed by React, while uncontrolled components manage their own state via refs",
          "Controlled components handle asynchronous operations, while uncontrolled components do not",
          "Controlled components are class components, while uncontrolled are functional components",
          "There is no difference"
        ],
        "answer": "Controlled components have their state managed by React, while uncontrolled components manage their own state via refs"
      },
      {
        "question": "How can you avoid prop drilling in React?",
        "options": [
          "By using the Context API",
          "By using `PropTypes`",
          "By using `useState` in child components",
          "By passing state to every child component"
        ],
        "answer": "By using the Context API"
      }
    ]
  }
  